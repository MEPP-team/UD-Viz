<!-- @format -->

<!DOCTYPE html>
<html>
  <head>
    <title>UD-Viz Local Avatar example</title>

    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  </head>
  <body>
    <script src="../dist/debug/udv.js"></script>
    <!-- <script src="./assets/js/udv.js"></script> -->
    <script type="text/javascript">
      const myWorld = new udv.Game.Shared.World({
        name: 'My World',
        origin: { lat: 45.7530993, lng: 4.8452654, alt: 300 },
        gameObject: {
          name: 'GameManager',
          static: true,
          components: {
            LocalScript: {
              conf: {
                nameGO2Focus: 'avatar',
                cameraAngle: 0,
                offsetZ: 2,
                minDist: 5,
                maxDist: 20,
              },
              idScripts: ['focus', 'localAvatar'],
            },
          },
        },
      });

      const app = new udv.Templates.LocalGame();
      app
        .start(myWorld, './assets/config/local_game_config.json')
        .then(function () {
          //set custom render pass
          const THREE = udv.THREE;

          //sobel shader
          const MySobelOperatorShader = {
            uniforms: {
              tDiffuse: { value: null },
              resolution: new THREE.Uniform(new THREE.Vector2()),
            },

            vertexShader: /* glsl */ `
      varying vec2 vUv;
      void main() {
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
      }
    `,

            fragmentShader: /* glsl */ `
      uniform sampler2D tDiffuse;
      uniform vec2 resolution;
      varying vec2 vUv;
      void main() {
        vec2 texel = vec2( 1.0 / resolution.x, 1.0 / resolution.y );
        //vec2 texel = vUv;
        // kernel definition (in glsl matrices are filled in column-major order)
        const mat3 Gx = mat3( -1, -2, -1, 0, 0, 0, 1, 2, 1 ); // x direction kernel
        const mat3 Gy = mat3( -1, 0, 1, -2, 0, 2, -1, 0, 1 ); // y direction kernel
        // fetch the 3x3 neighbourhood of a fragment
        // first column
        vec4 tx0y0 = texture2D( tDiffuse, vUv + texel * vec2( -1, -1 ) );
        vec4 tx0y1 = texture2D( tDiffuse, vUv + texel * vec2( -1,  0 ) );
        vec4 tx0y2 = texture2D( tDiffuse, vUv + texel * vec2( -1,  1 ) );
        // second column
        vec4 tx1y0 = texture2D( tDiffuse, vUv + texel * vec2(  0, -1 ) );
        vec4 tx1y1 = texture2D( tDiffuse, vUv + texel * vec2(  0,  0 ) );
        vec4 tx1y2 = texture2D( tDiffuse, vUv + texel * vec2(  0,  1 ) );
        // third column
        vec4 tx2y0 = texture2D( tDiffuse, vUv + texel * vec2(  1, -1 ) );
        vec4 tx2y1 = texture2D( tDiffuse, vUv + texel * vec2(  1,  0 ) );
        vec4 tx2y2 = texture2D( tDiffuse, vUv + texel * vec2(  1,  1 ) );
        // gradient value in x direction
        vec4 valueGx = Gx[0][0] * tx0y0 + Gx[1][0] * tx1y0 + Gx[2][0] * tx2y0 +
          Gx[0][1] * tx0y1 + Gx[1][1] * tx1y1 + Gx[2][1] * tx2y1 +
          Gx[0][2] * tx0y2 + Gx[1][2] * tx1y2 + Gx[2][2] * tx2y2;
        // gradient value in y direction
        vec4 valueGy = Gy[0][0] * tx0y0 + Gy[1][0] * tx1y0 + Gy[2][0] * tx2y0 +
          Gy[0][1] * tx0y1 + Gy[1][1] * tx1y1 + Gy[2][1] * tx2y1 +
          Gy[0][2] * tx0y2 + Gy[1][2] * tx1y2 + Gy[2][2] * tx2y2;
        // magnitute of the total gradient
        gl_FragColor = sqrt( ( valueGx * valueGx ) + ( valueGy * valueGy ) );
      }
    `,
          };

          //mask shader
          const MaskShader = {
            uniforms: {
              tDiffuse: { value: null },
              tMask: { value: null },
              resolution: new THREE.Uniform(new THREE.Vector2()),
            },

            vertexShader: /* glsl */ `
      varying vec2 vUv;
      void main() {
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
      }
    `,

            fragmentShader: /* glsl */ `
      uniform sampler2D tDiffuse;
      uniform sampler2D tMask;
      uniform vec2 resolution;
      varying vec2 vUv;
      void main() {
        gl_FragColor = vec4(0.);
  
        /*
        //gl_FragColor = vec4(mod(vUv*resolution, vec2(2.)), 0., 1.);
        //gl_FragColor = vec4(vec2(mod(vUv.x*resolution.x/5., 2.)), 0., 1.);
        float xgrad = mod(vUv.x*resolution.x, 10.)/10.;
        if(xgrad > 0.5)
          gl_FragColor = texture2D(tDiffuse, vUv);
        else
          gl_FragColor = texture2D(tMask, vUv);
        */
  
        vec4 maskTexel = texture2D(tMask, vUv);
        float maskFactor = max(max(max(maskTexel.x, maskTexel.y), maskTexel.z), maskTexel.w);
        gl_FragColor = vec4((1.- maskFactor) * texture2D(tDiffuse, vUv).xyz, 1.);
        // if(maskFactor <= 0.)
        //   gl_FragColor = texture2D(tDiffuse, vUv);
      }
    `,
          };

          //custom material
          const MYMAT = new THREE.ShaderMaterial({
            uniforms: {
              // logDepthBufFC:{value:1},
              // opacity: {
              //   value: 1.0
              // }
            },
            vertexShader: `
      #define NORMAL
  
      varying vec3 vNormal;
      varying float vDepth;
  
      #include <common>
      #include <logdepthbuf_pars_vertex>
  
      void main() {
        #include <beginnormal_vertex>
        #include <defaultnormal_vertex>
  
        //vNormal = normalize( transformedNormal );
  
        #include <begin_vertex>
        #include <project_vertex>
        #include <logdepthbuf_vertex>
  
        vNormal = normal;
        //vDepth = 1.0 + gl_Position.w;
        //vDepth = log(1.0 + abs(gl_Position.z));
        //vDepth = gl_Position.w;
        //vDepth = log(1. + abs(mvPosition.y));
      }
    `,
            fragmentShader: `
      #define NORMAL
  
      varying vec3 vNormal;
      varying float vDepth;
  
      #include <packing>
      #include <normalmap_pars_fragment>
      #include <logdepthbuf_pars_fragment>
  
      void main() {
  
        #include <clipping_planes_fragment>
        #include <logdepthbuf_fragment>
        #include <normal_fragment_begin>
        #include <normal_fragment_maps>
  
        gl_FragColor = vec4(packNormalToRGB( normal ), 0.);
        //gl_FragColor = vec4(packNormalToRGB( normal ), gl_FragCoord.w);
      }
    `,
          });
          MYMAT.flatShading = false;

          //renderTarget for special effects
          const renderTargetFX = new THREE.WebGLRenderTarget(0, 0, {
            depthBuffer: true,
            stencilBuffer: true,
          });

          const gameView = app.getGameView();

          //create custom render pass
          const renderer = gameView.getRenderer();

          //composer of all effect
          const composer = new udv.EffectComposer(renderer, renderTargetFX);

          //normal pass
          const normalsPass = new udv.RenderPass(
            gameView.getScene(),
            gameView.getCamera(),
            MYMAT
          );

          //add normal pass to composer
          composer.addPass(normalsPass);

          //sobel pass
          const sobelPass = new udv.ShaderPass(MySobelOperatorShader);

          //add it to composer
          composer.addPass(sobelPass);
          composer.renderToScreen = false;

          //final composer
          const finalComposer = new udv.EffectComposer(renderer);

          //render pass
          const renderPass = new udv.RenderPass(
            gameView.getScene(),
            gameView.getCamera()
          );

          //add it
          finalComposer.addPass(renderPass);

          //composition pass
          const compositionPass = new udv.ShaderPass(MaskShader);
          compositionPass.uniforms.tMask.value = renderTargetFX.texture;

          //add it to final composer
          finalComposer.addPass(compositionPass);

          //update variables on resize
          gameView.addResizeRequester(function (ctx) {
            const size = ctx.getGameView().getSize();
            renderTargetFX.setSize(size.x, size.y);
            sobelPass.uniforms.resolution.value = new THREE.Vector2(
              composer.writeBuffer.width,
              composer.writeBuffer.height
            );
            compositionPass.uniforms.resolution.value = new THREE.Vector2(
              composer.writeBuffer.width,
              composer.writeBuffer.height
            );
            console.log('resize ', size);
          });

          //define the custom render pass
          const customRender = function () {
            composer.render();
            finalComposer.render();
          };

          //set the custom render pass
          gameView.setRender(customRender);
        });
    </script>
  </body>
</html>
